{
    "link": "https://bbs.nga.cn/read.php?tid=39382396",
    "title": "[C/C++] 有道C语言编程题求大佬帮忙看看",
    "post_time": "2024-02-23 13:33",
    "uid": "60055910",
    "content": "求大佬帮忙看看",
    "replies": [
        {
            "mid": "64375529",
            "mtime": "2024-02-24 11:31",
            "mcontent": "没看懂你的思路，代码也没看懂但感觉有一丝丝不对劲。那个link_node，假如先读取(1，2)以及(2，3)，那么就可以推断1和3的距离是3，但接下来读取(1，3)的时候直接把正确最短距离用4覆盖了，到时候怎么挽回"
        },
        {
            "mid": "25583419",
            "mtime": "2024-02-24 11:45",
            "mcontent": "小哥 题的意思没理解到位   你看示例和文字描述   4  4 就是有4个城市 4条路    路的长度是2^K  是幂运算 不是2*K的 乘法运算。  下面的 1 2 ；2 3；1 3；0 1；按这个顺序连接道路的，第0条路是 城市1 到城市2距离就是2^0 = 1，第1条路是 城市2到城市3距离是2^1 = 2  ···· 以此类推。所以输出 第一行是0到1城市的 8   ····"
        },
        {
            "mid": "60055910",
            "mtime": "2024-02-24 17:54",
            "mcontent": "你是说64行那个嘛，我是在循环里面乘2的呀，那每次循环距离乘2不就相当于是冥函数了嘛因为2^63以上就不好存储和计算了，而且他结果的要求是取模100000的，也就是只要最后5位那我就在循环里面每次令路径距离*2，再取最后5位，那不就可以了嘛，因为不需要比较路径长度且不需要更新路径，所以也就不需要保存除了最后5位以外的数据。而路径相加的时候，也一样只需要最后5位呀。"
        },
        {
            "mid": "60055910",
            "mtime": "2024-02-24 17:56",
            "mcontent": "在处理(2, 3)的时候，就把矩阵中1，3和3，1更新了，不再是-1了，因此不会继续执行link_node(1,3)"
        },
        {
            "mid": "64375529",
            "mtime": "2024-02-24 20:08",
            "mcontent": "嗯是我看漏了61行的if，那不知道为啥了，而且不知道为什么你的代码我复制下来编译不过去，我只是兴趣自学的别行业人士学的语言也不是C。我自己瞎写了一通，发现有个地方和你不一样，虽然都是维护一个二维矩阵记录某个城市通往其他城市的距离，但我的思路是检查某个城市与其他城市的距离时，若是-1则进行一系列处理，把两个没有直接连接的城市通过一个中间城市连接起来；而你是对不是-1的进行处理。虽然直觉上我写的有漏洞但自己编了几个测试例子也都对"
        },
        {
            "mid": "43089971",
            "mtime": "2024-02-24 21:19",
            "mcontent": "先叠个甲,你这个题和代码我都没仔细看哈 放到gdb里面给你看了一下,监测dist数组,输入你给的那个示例初始化(4 4)这样是正常的我知道了,你那个renew_dist函数else if分支判断是不充分的,比如你给的示例第一条道路(1 2),当i==1的时候,if分支为假,但else if分支为真,所以执行了一次link_node(1,1),这是错误的我在else if判断里面加上了一个i!=from,重新测试可以得出正确的结果Code c:1:2:3:4:5:6:7:8:9:10:11:12:13:if (from != i &&\n    dist[from][i] != -1) {  // i是from下属结点，让to和i连接，并让i入(from队)\n  link_node(N, i, to, dist, (dist[from][i] + now_dis) % mod);\n  waitlist[0][length0] = i;\n  length0++;\n} else if (i != from && to != i &&\n           dist[to][i] != -1) {  // i是to的下属结点，让from和i连接，并让i入(to队)\n  link_node(N, i, from, dist, (dist[to][i] + now_dis) % mod);\n  waitlist[1][length1] = i;\n  length1++;\n}"
        }
    ]
}