{
    "link": "https://bbs.nga.cn/read.php?tid=42518054",
    "title": "有没有编程/业务大佬",
    "post_time": "2024-11-21 15:03",
    "uid": "64002889",
    "content": "实际生产中，有一笔还款交易。正确顺序是先先向下游发支付请求，然后过1分钟后向下游发送查询请求。",
    "replies": [
        {
            "mid": "64002889",
            "mtime": "2024-11-21 15:04",
            "mcontent": "请求顺序错乱"
        },
        {
            "mid": "60121980",
            "mtime": "2024-11-21 15:34",
            "mcontent": "改上游有很多改法，只改下游的话不知道"
        },
        {
            "mid": "64002889",
            "mtime": "2024-11-21 15:51",
            "mcontent": "是的，上游说白了，在支付交易发送半小时后再发起查询就行了"
        },
        {
            "mid": "3363460",
            "mtime": "2024-11-21 17:29",
            "mcontent": "上游会在发起支付请求的同时(不等支付请求返回)，就立即发起查询请求吗？或者再极端一点，不发起支付请求就直接发起查询请求吗？它拿什么查的？支付请求的 “过程” 和 “结果” 可以比较慢，但 “返回” 应该很快，告诉客户端：请求已收到，但结果现在没法给你，先给你一个 订单号 / token / session id，你拿着这个 订单号 / token / session id 发起查询请求。以充话费为例：上游向下游发起一个充值请求 { phoneNumber: 1380000000 } 之后，服务端会创建一个订单，并立即返回订单号 12345678，但充值并不会马上到账；上游拿到订单号后，每隔一段时间发起查询请求，或者等待下游主动回调。只要拿到了返回的订单号，就代表充值(支付)请求已经收到了；支付请求没返回，就没有订单号，就没法发起查询请求。"
        },
        {
            "mid": "63453772",
            "mtime": "2024-11-22 03:20",
            "mcontent": "有的，是标准操作，叫FIFO(first in first out)，标准数据库操作，基于你自己用的平台/语言自己找找"
        },
        {
            "mid": "8777681",
            "mtime": "2024-11-22 08:15",
            "mcontent": "如果要求上游任何都不改，我觉得没办法解决，要么丢到客户那边自己去重试、要么系统等段时间后异步再试一次了但这个场景中的终态一致性是上游要负责的事情吧，为啥LZ感觉在说下游要负责呢？这个我觉得才是问题点类似上游是商品出库流程之类，下游是支付之类上游肯定要等到下游的支付成功一致了，包括类似异步查到成功，上游才能推动出库流程呀"
        },
        {
            "mid": "63853781",
            "mtime": "2024-11-23 07:07",
            "mcontent": "下游的响应请求应该是单号不存在->触发上游按照1s，2s，3s，5s的延迟重新发起查询单号不存在->上游定时发起补单逻辑单号存在并失败->上游告知用户"
        },
        {
            "mid": "66352181",
            "mtime": "2024-11-23 15:22",
            "mcontent": "你能控制上下游的代码开发吗? 让支付和查询二者同时维持一个UniqueId, 下游收到先到的查询请求时校验UniqueId是否已知, 如果未知的话就抛弃这个请求或者响应给上游"
        },
        {
            "mid": "60367971",
            "mtime": "2024-11-24 04:01",
            "mcontent": "感觉整体思路应该是要利用流水号吧，补充一下查询这边应该是有原流水号的，如果原流水号不存在设个定时任务，时间到了再查一次要是还查不到就返回失败只改下游感觉没什么更优雅的办法啊"
        },
        {
            "mid": "12702204",
            "mtime": "2024-11-25 10:08",
            "mcontent": "上游发送支付信息给下游；下游支付操作；上游发送验证信息；表述的问题是出在支付操作ING，上游发送验证信息过来，我想的简单点...做个标记不就可以了，支付操作完成之后tag标1，验证信息发过来tag 非1 则过1min继续发，限制在5min内 >5min 默认支付失败"
        },
        {
            "mid": "61096428",
            "mtime": "2024-11-25 14:40",
            "mcontent": "下游查询已到达，未找到支付数据，起一个线(协)程，订阅支付数据生成的消息，然后查询请求的主线(协)程hold在那里，直到支付接口那边数据生成完毕，发布了消息，查询接口接收到了消息，再返回给上游。当然最好还是查询请求设置一个超时时间，否则上游一直请求，连接数会爆表。或者上游提供了非法的查询参数或是支付请求死在了半路，查询就永远停在那了。虽然提供了一种思路，但是真的不建议这样做。"
        },
        {
            "mid": "41775393",
            "mtime": "2024-11-29 09:15",
            "mcontent": "虽然我不是很明白什么样的请求能卡1分钟还接不到但按实际业务来说，你下游根本不需要做什么，查询的时候老老实实返回订单不存在，让上游做修改，等待交易请求返回正确的成功态之后才调用查询接口这种情况就不是你们下游的问题，也不该你们下游做修改，你总不能卡着线程等订单生成吧"
        }
    ]
}