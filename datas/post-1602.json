{
    "link": "https://bbs.nga.cn/read.php?tid=38995744",
    "title": "有没有c语言大佬，求教！",
    "post_time": "2024-01-15 00:03",
    "uid": "64495331",
    "content": "用gcc给程序插桩，大概效果是在每个函数前后各插入一个方法，方法内容可以自定义。方法的参数固定是当前函数的地址。在插入的末尾方法里怎么写能获取当前函数的临时变量呢？",
    "replies": [
        {
            "mid": "61937315",
            "mtime": "2024-01-15 01:04",
            "mcontent": "好怪的问题，能用全局变量吗"
        },
        {
            "mid": "43304940",
            "mtime": "2024-01-15 01:18",
            "mcontent": "你这玩法有点超纲了，估计一般做C语言的都答不出来。应该问问做编译器的，估计他们能有思路。"
        },
        {
            "mid": "64495331",
            "mtime": "2024-01-15 01:22",
            "mcontent": "想了半天好像没法实现，需要在malloc和free后面都插入代码，单纯函数前后插应该做不到，我再看看有其他什么办法吧，谢谢大佬们"
        },
        {
            "mid": "43089971",
            "mtime": "2024-01-15 02:03",
            "mcontent": "这个估计你得问gcc大佬了，编译器优化啥的对局部变量都会有影响我更想知道目的是什么？看你提到了malloc，是想追踪局部变量吗？或许可以试试gdb？ 另外我第一反应是写宏 如果可以改写函数的话，可以试试把所有局部变量打包到一个struct里面，传这个struct的指针想了一会，原生的c估计是没啥别的好办法了，就算写inline asm搞到rbp，void指针乱转也麻烦的一比，struct算是比较好的方法了"
        },
        {
            "mid": "42942044",
            "mtime": "2024-01-15 14:29",
            "mcontent": "一般我们想在一个函数前后加内容会用函数拦截的方式，给你需要插桩的函数加个wrapper，然后程序执行的时候通过LD_PRELOAD重定向动态链接库。 但是你说通过gcc的话，我也不知道 malloc和free的话应该可以通过重定向动态库解决？我和我同学插桩过一些底层的函数但是没有这么底层，或许可以试试("
        },
        {
            "mid": "7840469",
            "mtime": "2024-01-15 19:54",
            "mcontent": "提高变量所在位置？例如从函数内提到函数外"
        },
        {
            "mid": "64762033",
            "mtime": "2024-01-16 12:01",
            "mcontent": "纯小白。只说局部变量的话，似乎能从栈上直接拿到。不同编译器不同环境都不同，不建议在栈上乱搞。而且c弱类型，拿到了也不知道怎么解释吧至于动态分配的内存就更管不了了，封装一下malloc和free"
        },
        {
            "mid": "61559626",
            "mtime": "2024-01-16 14:22",
            "mcontent": "临时变量有的是存在栈上，可以通过汇编去读，但是具体的变量偏移是会被编译器优化的，所以不好确定。还有些临时变量是存在寄存器的，可能会被你调用函数这个行为干扰，要具体看是调用时保存到栈上还是属于那种scratch register，再去通过汇编访问。如果你没有强制要求是一个独立函数，又有源代码的话，用宏代替会比较好"
        },
        {
            "mid": "42662711",
            "mtime": "2024-01-16 16:54",
            "mcontent": "可以试试dlsym"
        },
        {
            "mid": "60335164",
            "mtime": "2024-01-17 09:23",
            "mcontent": "有个大概的思路，函数开头add rsp,0x28这样多开辟出来的栈空间就是局部变量。读取函数的二进制，匹配到add rsp汇编的机器码获取该函数的局部变量空间大小，根据当时rsp的值计算出变量地址。不过也能获取地址，空间大小，指针类型你不知道啊。整数小数结构体分辨不出来的。还有rsp寄存器值是变的你得解析这个函数你代码之前的所有汇编，有用到add rsp，sub rsp地方加减了多少你得还原回来"
        },
        {
            "mid": "60335164",
            "mtime": "2024-01-17 10:03",
            "mcontent": "这对象是自己的还是第三方的？如果是自己的好像可以通过解析符号表pdb文件实现。不过怀疑楼主功力，这些事不是那些写调试器的大牛干的吗。"
        },
        {
            "mid": "43331470",
            "mtime": "2024-01-17 11:53",
            "mcontent": "局部变量要在外部获取？  重写编译器吧"
        },
        {
            "mid": "42720291",
            "mtime": "2024-01-17 12:27",
            "mcontent": "你直接改源代码不就行了吗"
        },
        {
            "mid": "60058968",
            "mtime": "2024-01-17 12:57",
            "mcontent": "必须得插汇编了，用汇编取栈信息，然后解析。你用的插桩工具不支持的话还得自己实现。而且插桩实现还不能是表hook。但是有一说一，你的需求有问题，建议重新审视思路。如果是为了逆向的话，通常没必要取局部变量信息。99%的情况都不需要。如果是开发需要的话…从源码动手香多了，把日志系统改善一下。"
        },
        {
            "mid": "60437368",
            "mtime": "2024-01-17 14:10",
            "mcontent": "建议是直接使用自己魔改过的内存分配方法"
        },
        {
            "mid": "64495331",
            "mtime": "2024-01-17 23:22",
            "mcontent": "谢谢各位佬，已经准备手动改源代码插桩了"
        },
        {
            "mid": "42766902",
            "mtime": "2024-01-18 03:22",
            "mcontent": "有函数的地址看下栈的偏移呀，指针直接指过去就行了，局部变量的偏移应该是ebp-4"
        },
        {
            "mid": "65459539",
            "mtime": "2024-01-18 11:56",
            "mcontent": "试试用ast找？"
        },
        {
            "mid": "43287184",
            "mtime": "2024-01-18 13:29",
            "mcontent": "原则上用函数地址偏移出一个参数地址就行了你这一整套东西，要不参考下valgrind的源代码看看人家怎么玩的？"
        }
    ]
}