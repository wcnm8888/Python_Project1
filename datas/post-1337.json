{
    "link": "https://bbs.nga.cn/read.php?tid=39596907",
    "title": "[求助]关于数据库id用代码自增的情况下多线程问题",
    "post_time": "2024-03-18 09:49",
    "uid": "60401170",
    "content": "现在表中有一行id是需要手动自增+1的，我的做法是通过读取该行最大值然后+1再新增数据，但是在高并发下会读取同一行数据自增+1，然后触发数据库的Id不可重复。导致100条并发只能存进去4条。",
    "replies": [
        {
            "mid": "42364871",
            "mtime": "2024-03-18 09:52",
            "mcontent": "雪花算法考虑下？"
        },
        {
            "mid": "60401170",
            "mtime": "2024-03-18 10:29",
            "mcontent": "雪花算法产生的是64位id，但本身数据库他id结构是有格式且是8位。我需要从数据库中读最大id然后才能做自增的操作"
        },
        {
            "mid": "37449036",
            "mtime": "2024-03-18 11:12",
            "mcontent": "没看懂，你是要求分布式CAP全要？还是想要单一一个库更高的性能？什么其他的都不要只要ID严格递增的话直接建个queue一个一个排队执行不行吗"
        },
        {
            "mid": "64399684",
            "mtime": "2024-03-18 12:05",
            "mcontent": "我建议不要代码里控制id生成，将自增id交给数据库处理。mysql8是有高并发自增处理功能的，其他数据库肯定也有。"
        },
        {
            "mid": "64057759",
            "mtime": "2024-03-18 12:51",
            "mcontent": "单机项目，你先生成id到队列中，用的时候从队列获取就行。集群项目，生成id到redis，用的时候从redis拿。不就。。。"
        },
        {
            "mid": "8777681",
            "mtime": "2024-03-18 16:47",
            "mcontent": "同4F自增怎么能用查询做的非要查询做那就得加锁啊，如果是集群还要做分布式锁一般都是数据库表机制上的自动的自增列或者就是顺序要求不高的情况下 时间+随机id"
        },
        {
            "mid": "38358994",
            "mtime": "2024-03-18 20:48",
            "mcontent": "你还不如把ID在数据库中设置为自增类型 不要在代码中处理ID"
        },
        {
            "mid": "60401170",
            "mtime": "2024-03-19 15:39",
            "mcontent": "不能动数据库"
        },
        {
            "mid": "38358994",
            "mtime": "2024-03-19 16:04",
            "mcontent": "那就用原子变量做ID"
        },
        {
            "mid": "42660780",
            "mtime": "2024-03-19 16:35",
            "mcontent": "麻烦点但是合理点改数据库字段结构用雪花算法，一定要这么干丢到队列里一条一条处理，或者说做cas这种先查后增异常在套一边直到成功。"
        },
        {
            "mid": "63782286",
            "mtime": "2024-03-20 09:35",
            "mcontent": "应用层实现一个自增，很麻烦，收益很小，成本很高。你可以解释一下产品层面你的需求到底是什么吗？提问的时候应该描述你最原始想要解决的问题，而不是自己先想一个不可行的方案，结果发现里面有问题解决不了又去问别人怎么解决这个新问题。"
        }
    ]
}