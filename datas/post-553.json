{
    "link": "https://bbs.nga.cn/read.php?tid=29640697",
    "title": "私底下搞了一套自己的编程语言，想让坛友看看设计得怎么样",
    "post_time": "2021-11-29 13:01",
    "uid": "42708080",
    "content": "链接：",
    "replies": [
        {
            "mid": "63205728",
            "mtime": "2021-11-29 15:40",
            "mcontent": "介绍介绍哈，你直接给了链接 没有任何欲望点开。"
        },
        {
            "mid": "62409105",
            "mtime": "2021-11-29 15:34",
            "mcontent": "不想说太难听，但是这都快2202年了，怎么还在用#include来处理模块间的依赖关系，隔壁c++都上modules了"
        },
        {
            "mid": "60669616",
            "mtime": "2021-11-29 15:40",
            "mcontent": "你试图对C语言进行改进，你可以聊聊你改进在了什么地方吗目前而言整个文档逻辑非常稀碎，很多对实现敏感而重要的东西你都一笔带过了而且你对面向对象的支持似乎只是对实现的一种编译期要求，那甚至可能还不如C手撸虚表方便"
        },
        {
            "mid": "42708080",
            "mtime": "2021-11-29 15:45",
            "mcontent": "还不清楚module的机制，是根据老版的C++进行改进的"
        },
        {
            "mid": "42708080",
            "mtime": "2021-11-29 15:53",
            "mcontent": "什么叫对实现的一种编译器要求，能详细解释一下吗"
        },
        {
            "mid": "42708080",
            "mtime": "2021-11-29 15:54",
            "mcontent": "而且我看许多现在的代码也都用的是include啊，应该不至于这么快过时吧"
        },
        {
            "mid": "60669616",
            "mtime": "2021-11-29 15:58",
            "mcontent": "太长了 没有例程代码不好理解，我感觉你目前的对于面向对象的支持相当于说是实现了一套语义检查规则，对于方便写码没有太大的帮助。要不你搞几个example code出来  写几个基础的容器类之类的 贴到主楼大家看这个好理解一些或者说你把你的规范转成EBNF规范一点来书写大家也好理解一些，后面你想实现有EBNF还方便用前端生成器搞前端另外个人的建议是  想改进C语言不妨先写个简单的C编译器，我觉得帮助会挺大的，现在工具链挺完整的  用好lex yacc llvm 写一个简单的C语言编译器还是不难的"
        },
        {
            "mid": "62409105",
            "mtime": "2021-11-29 16:12",
            "mcontent": "另外你的文档写的非常稀碎，大部分的特性基本就是相比与c只是换了种写法而已。甚至还有指针的关键字被改为address和没有enum这种倒车行为。基本上所有我认为有改变的地方你都一笔带过了。首先是你把异常抽象出一个单独的类型，但你没有写明一个函数抛出异常时的具体行为，等于是漏了最关键最能看出设计好坏的部分。interface的设计堪称迷中迷。本来interface存在的目的就是抽象出一组接口，使得处理这个接口的部分能按照统一的方式处理所有实现该接口的对象。你这倒好，你的类型系统完全没有泛型的概念，于是你选择在定义interface的时候需要声明实现了该interface的object. 但问题在于，interface是为了加强泛型的抽象与表达能力，你这里却完全没有泛型，那我该怎么使用这个interface呢？你在文档中没有提及。等于这个interface就是完完全全一点用没有的设计。其他的还有默认参数那块我根本没看懂你想表述什么；宏的设计没写明白，如果只是文本替换那对比c都是倒退，没有任何存在的必要等等update：照lz的描述，看样子所谓的引用是在语言层面提供了实现引用计数生命周期管理的基础。需要提醒一下，引用计数基本已经被研究烂了，这并不是一个“创新”"
        },
        {
            "mid": "60829121",
            "mtime": "2021-11-29 16:25",
            "mcontent": "前面几位说的比较委婉，我来帮他们翻译一下：你写的全都是垃圾。文档写的逻辑不清，和C一致的部分和你自己写的东西完全混在一起。范畴、链接这种机制提供的访问控制毫无意义，基于名称的权限控制在给程序员制造困扰的领域数一数二。接口的设计很有特色，除了特色没什么好说的。java/C#的接口比这个成熟的多。C++通过require和template的结合也完全可以实现鸭子类型，在类定义里添加静态的标识变量可以避免自动的成为某个接口，基本也能做出静态的接口机制。创新部分全是垃圾不说，从C++继承到的部分基本也全是垃圾。goto这种东西以你的水平估计是用不好的。然后是union，你猜猜C++17为什么提供了variant替代union？因为不显式存储数据类型RAII就没法做。对于一个变量控制多个union类型的情况，variant<tuple>能做的一样好。最后C++里最大的问题之一，包管理你完全没提，就算没有cargo那种语言本身集成包管理+单元测试的设计，至少做到maven这个等级是现代语言的底线了吧？结果还要手动管理。通篇看完，只能说是完全在意料之中的垃圾。"
        },
        {
            "mid": "60829121",
            "mtime": "2021-11-29 16:31",
            "mcontent": "include倒也不是完全没用，对于一些需要支持多语言的协议，比如protobuf之类的，是有用include插入宏简化代码生成的技巧的。但用include管理依赖确实是全方面的灾难。"
        },
        {
            "mid": "42708080",
            "mtime": "2021-11-29 16:34",
            "mcontent": "能仔细说一下链接和范畴的控制为什么毫无意义吗，我需要知道这一点"
        },
        {
            "mid": "42708080",
            "mtime": "2021-11-29 16:43",
            "mcontent": "还有raii我查了一下指的是资源获取即初始化，好像是讲创建的对象最终会被析构的机制，能详细解释一下这一点吗"
        },
        {
            "mid": "60829121",
            "mtime": "2021-11-29 16:47",
            "mcontent": "Reply to +R by  [LeLeMoe] (2021-11-29 16:41)protobuf是个跨语言的数据传输协议。用法上大概是先用它自己的语言写一个数据格式，然后对每个语言生成对应的文件用来序列化/反序列化数据。它生成的C++代码里就有用include简化重复代码的技巧。这个只能说用于代码生成代码是无所谓的，毕竟生成的代码不是人维护。自己写肯定不推荐那么做。"
        },
        {
            "mid": "42708080",
            "mtime": "2021-11-29 16:48",
            "mcontent": "另外包管理我查百度只查到安装程序时的一些事情，这个是什么意思，可以解释一下吗"
        },
        {
            "mid": "60829121",
            "mtime": "2021-11-29 16:49",
            "mcontent": "范畴和链接对权限的控制都是基于函数名的。我完全不理解这种设计的必要性在哪里。这意味着让我要写一个新函数访问特定数据的时候，我还要修改数据类型的定义。当然你可以说这不是大问题，但我只觉得这套东西从易用性上完全不如C++的public/private。RAII用于保证一个变量在构造的时候就申请了必要的资源，并且在析构的时候自动释放它们。虽然这是个C++专有的特性，但几乎所有常见的语言都有类似的机制：java的try，python的with，等等。举个例子就是C++的智能指针，析构时自动释放内存，避免内存泄露。但union的析构是有坑的。包管理说的是那么一个问题：有个人A他写了一段代码，我想用。那怎么做呢？最简单的办法就是把他的代码贴到自己的代码里，然后维护起来就一头包。代码量小的时候还好说，复杂起来考虑这样一个问题，A依赖B和C，B和C依赖D，这个时候怎么避免D被依赖了两次。手动删除重复代码当然可以，项目一大除了维护依赖就不用干别的了。看起来你还是想写点东西的，那我建议你多学几种语言，然后再想想这些语言为什么这么设计，最后再设计新的语言。你现在可能觉得自己设计了大量炫酷的新特性，等你写的代码稍微多一点，就会发现这些东西全都在恶心自己。"
        },
        {
            "mid": "62409105",
            "mtime": "2021-11-29 17:04",
            "mcontent": "是我没表达清楚，我想说的是这里的论证方法并不正确。正确的逻辑关系是：你需要在这里简化重复代码，而使用include来包含这部分重复代码是一种可行的方案。但是简化重复代码的方法又是跟语言相关的，我认为不能因为在c/c++下面使用了include来简化重复代码，就认为include的存在是必要的。 想了下，是我说的太绝对了，我反对的是依然用include来处理modules间的依赖关系，其他的时候就得具体问题具体分析了。"
        },
        {
            "mid": "42708080",
            "mtime": "2021-11-29 17:07",
            "mcontent": "当一个新函数要想访问旧数据类型当然要修改数据类型的定义啊，因为有人需要查这个东西嘛(这是其他给我建议的人这么说的)。另外链接不是基于函数名的，链接的名称可以是随意的，不论是否和函数或其他数据类型重名。另外，union我当初的考虑是这是一个c语言具有的一般功能，我只是想把它一般地继承过来罢了。包管理的解释还是看不懂，函数不都有功能注释嘛，维护的时候专注于功能注释和参数列表不就行了(肤浅的见解)。"
        },
        {
            "mid": "62409105",
            "mtime": "2021-11-29 17:18",
            "mcontent": ""
        }
    ]
}